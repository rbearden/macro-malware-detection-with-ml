import os, gzip


""" Defines utilities for file management
"""

class Util:

    SUCCESS = 1
    FAILURE = 0

    def __init__(self):
        return

    # returns list of recursively found files
    def get_files(self, directory):
        entries = os.listdir(directory)
        files_in_dir = []

        for entry in entries:
            full_entry_path = directory + "/" + entry
            if os.path.isfile(full_entry_path):
                files_in_dir.append(full_entry_path)
            else:
                files_in_dir.extend(self.get_files(full_entry_path))

        return files_in_dir

    # delete files from dir2 whose IDs are not in dir1
    def delete_xtra_files(self, dir1, dir2):
        files_to_del = []
        missing_files = []
        dir1_file_ids = [f.split('.')[0] for f in os.listdir(dir1)]

        for fname in os.listdir(dir2):
            if fname.split('.')[0] not in dir1_file_ids:
                fpath = os.path.join(dir2, fname)
                files_to_del.append(fpath)
        for f in files_to_del:
            os.remove(f)

        dir2_file_ids = [f.split('.')[0] for f in os.listdir(dir2)]
        for fname in os.listdir(dir1):
            if fname.split('.')[0] not in dir2_file_ids:
                missing_files.append(fname.split('.')[0])
        print('{} is missinds IDs...'.format(dir2))
        print(missing_files)

    # unzips src file to dest dir
    def unzip_gz(self, src, dest):
        file_name = self.get_file_base_name(src)

        try:
            # make sure src is a file and dest is a directory
            if not os.path.isfile(src):
                print('     PROBLEM WITH SOURCE   ')
                raise Exception('src was not a file')
            if not os.path.isdir(dest):
                print('     PROBLEM WITH DESTINATION    ')
                raise Exception('dest was not a directory')

            # read binary of unzipped src file to 'file_content'
            with gzip.open(src, 'rb') as f:
                file_content = f.read()

            # open new file in dest to which to write unzipped file
            new_file = dest + "/" + file_name

            with open(new_file, 'wb') as f:
                f.write(file_content)
                f.close()

            print('   NEW FILE NAME: ' + new_file)

            return self.SUCCESS                         # file successfully unzipped

        except Exception as e:
            print('Error occurred unzipping ' + src + ' to ' + dest)
            print('{}'.format(e))

            return self.FAILURE                         # failed to unzip file

    ''' File path operations
    '''

    # Returns name of file, including file ext(s)
    def get_file_name(self, file_path):
        file_path.replace("\\", "/")                      # use forward slash in file string
        src_components = file_path.split("/")             # get each file/dir in list
        nbr_components = len(src_components)              # number of file/dir in file path
        file_name = src_components[nbr_components - 1]    # file name is last component in list

        return file_name

    # Returns name of file, stripped of last file ext(s)
    def get_file_base_name(self, file_path_or_name):
        file_name = self.get_file_name(file_path_or_name) # get file name
        name_components = file_name.split(".")            # get list of components before and after '.'

        file_base_name = ''                               # empty base name
        index = 0                                         # index starts at 1
        comp_len = len(name_components)                   # number of file name components
                                                          #     format: [name].[ext 1].[ext 2]...[ext n]

        while index < comp_len - 1:
            file_base_name += name_components[index]      # add next name component to base name
            if index < comp_len - 2:                      # if not last component, add '.'
                file_base_name += '.'

            index += 1                                    # increment index

        return file_base_name
